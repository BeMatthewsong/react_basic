# 최적화의 필요성
대부분의 서비스는 최적화를 깊이 고려하지 않아도 문제없이 작동이 된다.
초기에는 웹 페이지가 단순한 정적 컨텐츠를 표시하는 데 사용되었지만, 웹 애플리케이션은 점차 **복잡한 상호작용과 다양한 기능**이 포함하게 되면서 화면을 렌더링하는 과정이 느려지기 시작하였다. 특정 기능에 연관되어 있는 변수, 함수, 컴포넌트 등으로 인해 재렌더링되기 때문에 렌더링 속도에 영향을 준 것이다. 
<br/>
그래서 렌더링 속도를 빠르게 하기 위해서 불필요한 재렌더링을 막는 최적화 과정이 필요하게 되었다. 

> 재렌더링 되는 조건
>- props가 바뀔 때
>- state가 바뀔 때
>- 부모 컴포넌트가 리렌더링될 때
>- 전역 상태로 쓰고 있는 중앙상태값이 변할 때

# 최적화의 방법

## useMemo : 변수 메모이제이션
이 함수는 React Hook 중 하나로서 React에서 CPU 소모가 심한 함수들을 캐싱하기 위해 사용된다. <br/>
**즉, 무거운 연산을 통해 얻어내는 값을 메모이제이션하기 위해 useMemo를 사용한다.**  <br/>

> Memoization(메모이제이션)
>
>프로그램 실행 시 이전에 계산한 값을 저장한다
>원하는 값이 바뀌지 않았다면 이전에 연산했던 결과를 다시 사용하는 방식입니다.

### useMemo 사용법
```js
const value = useMemo(() => {
    return calculate();
},[item])
```
의존성 배열 안에 item이 바뀔 때마다 콜백 함수를 다시 호출하여 메모리에 저장된 값을 업데이트해준다.
만약에 빈 배열을 넣는다면 마운트될 때만 실행된다. 

### 만약에 useMemo를 쓰지 않는다면?
만약 컴포넌트내의 어떤 함수가 값을 리턴하는데 하나의 변화에도 값을 리턴하는데 많은 시간을 소요한다면 이 컴포넌트가 리렌더링 될 때마다 함수가 호출되면서 많은 시간을 소요하게 될 것이다.
또 그 함수가 return되는 값이 자식 컴포넌트에도 사용이 된다면, 그 자식 컴포넌트도 함수가 호출 될 때마다 새로운 값을 받아 리렌더링 된다.

만약 컴포넌트 내에 어떤 함수가 값을 리턴하는데 많은 시간을 소요한다면, 이 컴포넌트가 리렌더링 될 때마다 함수가 호출되면서 많은 시간을 소요하게 될 것이고, 그 함수가 반환하는 값을 하위 컴포넌트가 사용한다면 그 하위 컴포넌트는 매 함수호출마다 새로운 값을 받아 리렌더링할 것이다.

## useCallback : 함수 메모이제이션
이 함수는 useMemo와 비슷한 방식으로 동작이 된다. 다만 차이점으로는 useMemo는 리턴값을 받는 변수 메모이제이션이고, **useCallback은 함수 메모이제이션이다. 그래서 무거운 연산을 하는 함수를 담는 게 바람직하다.** <br/>

### useCallback 사용법
```js
const onCreate = useCallback(() => {
    const user = {
      id: nextId.current,
      username,
      email
    };
    setUsers(users.concat(user));

    setInputs({
      username: '',
      email: ''
    });
    nextId.current += 1;
  }, [users, username, email]);
```
useMemo, useEffect와 동일하게 의존성 배열에 있는 값이 변하면 콜백함수가 실행된다.

## useMemo와 useCallback의 차이 (요약) 
- useMemo : 함수는 메모이제이션된 `값`을 반환한다
- useCallback : 함수는 메모이제이션 된 `함수`를 반환한다
